操作系统在实现它的功能的时候也用到了很多数据结构，最为重要的就是栈这样一种数据结构。本文将从 Linux 操作系统中几个重要的场景讲解栈的应用。

1 函数调用

2 进程中局部变量的管理

# c write back cache emulater

这个项目的目标是模拟在基于堆栈的机器上使用回写缓存的小型类似c语言的程序的执行，并报告程序执行的一些指标。

该项目的成功完成将增强您对C11编程语言的一些特性的理解，并发展您对如何在通用计算机体系结构上执行简单程序的理解。

## The stack-based computer architecture

目标计算机是基于堆栈的计算机，没有通用寄存器。堆栈用于保存算术计算期间的临时结果，内存地址用于管理每个程序的执行流(后面将介绍)。

**Control registers**

PC -程序计数器，保存着要从计算机的RAM中取出的下一条指令的内存地址。

SP -堆栈指针指向计算机堆栈顶部的 word

FP - 帧指针指向计算机堆栈的当前函数的激活帧(稍后将介绍)。

cpu上的控制寄存器被修改以响应每个程序的指令。例如，一条要求将一个整数推入堆栈的指令会导致SP被修改。类似地，函数调用的结果是PC的值被压入堆栈，PC被修改为指向被调用函数的第一条指令。

**16 位字**

**main memory and cache memory**

1. CPU只包含三个非常快的CPU上控制寄存器:PC、SP和FP，但是这些寄存器不能用作存储任意值的通用内存位置。这些寄存器只能通过对程序指令的解释而改变。
2. cache-memory是一组相对较快的内存(通常比主存快8-20倍，但不如CPU的寄存器快)，总共只存储32(25)个 words
3. 主存是一个相对较慢的内存“库”，用来存储程序的指令、数据和运行时堆栈，总共存储64K 个 words。

因为高速缓存比主存小得多，每个高速缓存位置必须同时记住它的数据和数据“所属”的主存位置。当一个词从主存通过高速缓存复制时，这个词的地址总是“镜像”在相同的高速缓存位置。每个主存位置只有一个缓存位置，但是每个缓存位置有许多潜在的主存位置。因此，每个缓存位置必须记住它正在缓存的主存位置。

从主存读取的每个单词都被高速缓存保留下来，如果需要再次读取，就会迅速从高速缓存中取出，而无需向主存“请求”另一个(相同的)副本。当所需的数据在缓存中可用时，我们就进行缓存命中。但是，如果所需的数据在缓存中不可用，则必须首先从主存中取出。这被称为cache-miss。

当CPU写入数据字时，缓存有两个潜在的操作过程:

1. 它可以立即把这个单词写进主存储器。因为没有其他组件可以修改主存，所以缓存和主存总是同步的。这被称为 write-throught 策略。简单。
2. 或者，高速缓存可以记住新单词，但不会立即将它复制到主存。缓存和主存现在不同步了。缓存可以满足未来对同一个单词的任何读请求。但是，如果请求的字不在缓存中，就必须在将其从主存复制到CPU的过程中。由于新单词需要与先前未写入主存的数据相同的缓存位置，所以现在必须先执行延迟的写入主存的操作。对于缓存的每个单词，我们需要记住它是否正确地反映了主存中的内容——缓存的副本是干净的还是脏的。脏数据需要先写入主存，然后才能重用缓存位置来存储主存中的新数据。这被称为回写策略

**the instruction set**

有 17 个指令。每个指令有一个整数值，每个指令占用一到两个内存 words。

有些指令，例如'add'，不需要额外的信息(这里，因为要添加的值驻留在堆栈中)。“add”指令后面的下一个单词就是下一条要执行的指令。'add'是 0 操作数指令的一个例子，总共需要一个 words。

一些指令，如'call'需要额外的信息。“调用”指令之后的下一个 words 是要调用的函数的第一条指令的内存地址。'call'是一个 1 操作数指令的例子，总共需要两个 words。	

**calling and returning from functions**

每个函数都使用堆栈上的内存来保存传入参数和局部变量。这个内存区域称为堆栈帧，并驻留在堆栈上。cpu上的控制寄存器FP(帧指针)允许我们定位当前函数的帧。函数执行时访问参数和局部变量的代码是根据对FP的偏移量生成的。参数出现在“高于”FP(在高地址，正偏移量)，局部变量出现在“低于”FP(在低地址，负偏移量)。在函数执行过程中，当值被推入或弹出堆栈时(例如为调用另一个函数而推入参数)，堆栈指针SP可能会发生变化。但是，FP在函数的执行过程中不会改变。

# 参考资料

https://blog.csdn.net/yangkuanqaz85988/article/details/52403726

