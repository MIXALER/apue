## Linux系统编程

## 1 shell

终端是一系列输入输出设备的总称

## 2 unix目录和文件

bin 存放可执行文件

boot 存放开机时启动例程

dev 存放设备文件

etc 存放当前系统的用户配置文件信息， passwd 存放用户名，密码信息

lib 库路劲

media mnt 挂载磁盘

opt proc 进程相关

usr unix software resource 简称，第三方库的lib所在的

linux中，所见皆文件



### 2.1 软连接（ windows 下的快捷方式）和硬链接

软连接：ln -s ，存放的是路径名，可以存放 相对路径 和 绝对路径（可以任意搬离）

硬链接：ln ， 修改其中任一个文件，其余的文件会随之改变。硬链接的文件是同步的，windows下没有。

inode节点实现硬链接，硬链接所连接的inode节点相同

删除其中一个，硬链接连接的所有文件不会同时删除，只是将硬链接计数减一

操作系统给每一个文件赋予唯一的Inode，当有相同的Inode文件存在时，彼此同步。

## 3 文件属性和用户用户组

### whoami

查看当前登录用户

### chmod

文字设定法

数字设定法

r: 4 w: 2 x: 1 

### chown

设定所有者，所有组

### chgrp

设定所有组

## 4 查找与检索

linux 不以文件后缀名作为文件类型的标准，一共7种文件

### 4.1 find

找文件

### 4.2 grep

以文件内容做为搜索对象

### 4.3 xargs

将find搜索结果集执行某一指定命令。当结果集数量过大时，可以分片映射。

## 5 安装卸载软件

### 5.1 apt-get

5.2 源码安装

## 6 gcc

编译执行程序4步骤：预处理，编译，汇编，链接

### 6.1 预处理

展开宏，头文件

替换和条件编译

删除注释，空行，空白

### 6.2 编译

检查语法规范，生成汇编代码，消耗时间和系统资源最多

### 6.3 汇编

将汇编指令翻译成机器指令

### 6.4 链接

数据段合并

数据地址回填

### 6.5 gcc 编译参数

gcc -E 预处理，-S 编译， -c汇编， 链接无参数

-I ： 指定头文件所在目录位置

-g ： 编译时添加调试语句，加了可以调试，不加不能调试，主要支持gdb调试

-On : 支持优化，0-3，数字越大优化级别越高

-Wall : 显示所有的警告信息

-D : 编译的时候注册宏，向程序中动态动态注册宏定义，将一个宏定义作为开关时有用

## 7 静态库和共享库

### 7.1 静态库

提高编译效率和开发效率，实现代码重用。

实在可执行程序运行前就加入到执行代码中，称为执行程序的一部分；共享库，实在执行程序启动时加载到执行程序中，可以被多个执行程序共享使用

建议使用共享库，比较明显的优势在于库是独立的，便于维护和更新；而静态库的更新比较麻烦，一般不做推荐。静态库运行较快，动态库运行较慢（但是现在差不多了），对空间要求较低，而时间要求较高的核心程序中（操作系统启动例程）。

ar rcs libmylib.a file1.o

### 7.2 共享库（动态链接库）

## 8 Makefile项目管理

脚本：把系列的命令集合放在一个文件中批量的去执行它

### 8.1 用途

项目代码编译管理

节省编译项目实践

一次编写终身受益

### 8.2 基本规则

1.  若想生成目标，检查规则中的依赖条件是否存在，若不存在，则寻找是否有规则来生成该依赖文件
2.  检查规则中的目标是否需要更新，必须先检查它的所有依赖，依赖中有任意一个被更新，则目标必须更新

all:  指定 makefile 的终极任务

### 8.3 Makefile函数

1.  找到当前目录下所有后缀为 .c 的文件，赋值给 src

    `src = $(wildcard *.c)`，$ 表示一个函数调用，wildcard 表示函数名，*.c 表示函数函数，函数的值返回给 src 变量

2.   把 src 变量里所有后缀为 .c 的文件替换成 .o 

     `obj = $(patsubst %.c, %.o, $(src) )`

3.  clean "-" 的作用是，删除不存在的文件时，不报错，顺序执行

## 8.4 Makefile自动变量

1.  `$@` : 在规则的命令中，表示规则中的目标
2.  `$<` : 在规则的命令中，表示规则中的第一个条件，如果将该变量应用在模式规则中，它可将依赖条件列表中的依赖依次取出，套用模式规则
3.  `$^` : 在规则的命令中，表示规则中的所有条件，组成一个列表，以空格隔开，如果这个列表中有重复的项则消除重复项。

### 8.5 模式规则

`%o : %c`

​		`gcc -c $< -o $@`

静态模式规则

`$(obj) : %o : %c` 

​		`gcc -c $< -o %@`

伪目标：

​	.PHONY : clean ALL







​	

## man手册

是系统的手册分页程序，也是系统最重要的参考资料

man 手册分为9个章节

1.  可执行程序或shell 命令
2.  系统调用
3.  库调用
4.  特殊文件
5.  文件格式和规范
6.  游戏
7.  杂项
8.  系统管理命令
9.  内核制程

## 系统调用

什么是系统调用：

由操作系统实现并提供给外部应用程序的编程接口，是应用程序与系统之间数据交互的桥梁。

## 常用系统调用

### open / close 函数

open函数返回一个整数，表示一个文件描述符。

### read / write 函数

```c++
#include <unistd.h>

   ssize_t write(int fd, const void *buf, size_t count);
```

```c++
#include <unistd.h>

   ssize_t read(int fd, void *buf, size_t count);
```

参数：

-   fd 文件描述符
-   buf 存数据的缓冲区和待写出的缓冲区
-   count 缓冲区的大小和数据大小

返回值

-   成功：读到的字节数，写入的字节数，0表示读到文件末尾
-   失败 -1 并设置 errno = EAGIN 或 EWOULDBLOCK ，说明而是read以非阻塞方式在读一个网络文件或设备文件，且文件无数据

### perror函数

void perror(const char*)

错误提示函数，能输出具体的错误信息



### strace 命令

跟踪程序执行过程中所用到的系统调用和信号



### 文件描述符

PCB 进程控制块， 本质 结构体

成员， 文件描述符 ，0/1/2/3/4 /... /1023

其实每个文件描述符对应的也是一个结构体，被操作系统隐藏。

为什么fd为3呢

0 为 STDIN_FILENO 1 为STDOUT_FILENO 2 为STDERR_FILENO

一个进程最多能打开1024个文件，每次打开都是可用的最小的那个

### 阻塞，非阻塞

是设备文件，网络文件的属性

读常规文件是不会阻塞的

读设备文件，读网络文件

/dev/tty -- 终端文件

open("/dev/tty", O_RDWR | O_NONBLOCK) 设置为非阻塞

### fcntl 函数

改变一个**已经打开文件**的访问控制属性

